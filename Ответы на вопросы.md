**Вопрос 1: Как работает система сцены в Godot и в чем ее преимущества?**

Сцена - это основной элемент игры, который строится из узлов (Node). 
Сцена по сути является префабом из Unity. Каждую сцену можно инстанцирвоать много раз в другие сцены.

Преимущества системы сцен:
- **Модульность** - каждая сцена независима
- **Переиспользование** - сцены можно инстанциировать много раз
- **Изоляция** - изменения в одной сцене не ломают другие
- **Работа в команде** - разные разработчики могут работать над разными сценами
- **Отладка** - можно тестировать сцены по отдельности

Блок-схема платформера на Godot:
Загрузочный экран (loading_screen.tscn, loading_screen.gd)

-> (загружается основное меню)

Главное меню (main_menu.tscn)

-> (по нажатию кнопки старт загружается сцена с игрой)

Сцена с уровнем 1 (level_1.tscn)

-> (после победы игрока загружается новый уровень)

Сцена с уровнем 2 (level_2.tscn) ...

-> (после поражения или нажатия кнопок для выхода в меню игрок переходит в главное меню)

Главное меню (main_menu.tscn)

**Вопрос 2. Объясните, как работают сигналы (Signals) в Godot?**

Сигналы - это сообщения, которые узел может "испускать" (emit), а другие узлы могут "подписываться" (connect) на эти сообщения.
Принцип работы заключается в следующем: в одном узле происходит инициация сигнала, а также происходит emit, когда это необходимо. В дугом месте проекта другой узел подписывается на него так, чтобы при испуске сигнала запускаться необходимый метод.

Пример из проекта:
coin_collider.gd
	
	signal collected
	
	func _on_body_entered(body: Node2D): 
  
	  if body is CharacterBody2D and body.get_script() == preload("res://Scripts/player_char.gd"):
    
		  emit_signal("collected")
      
		  queue_free()

main_scene.gd

func connect_to_coins():

	var coins = get_tree().get_nodes_in_group("coins")
	for coin in coins:
		coin.collected.connect(_on_coin_collected)

**Вопрос 3. Как в GDScript организовать наследование, и зачем это нужно?**

Чтобы организовать наследование, необходимо:
1. Задать класс словом class_name
2. Создать класс наследник, который тоже имеет class_name, однако также неоходимо добавить слово extends, после которого указать имя класса родителя.
3. В классе родителя можно создать методы, которые можно реализовать или переоределить в наследниках.
4. Это необходимо для избежания повторного использования кода, упрощения структуры проекта, реализации полифорфизма, упрощения расширяемости.
Пример из проекта:

Класс родитель game_state.gd

	class_name GameState

	extends Node

Класс наследник game_over_state.gd

	extends GameState

	сlass_name GameOverState

**Вопрос 4. Как работает система импорта ресурсов в Godot? Что произойдет, если изменить исходный файл изображения?**

Процесс импорта в Godot выглядит следующим образом: в движок загружается исходный файл (.png, .jpg ...), там он компирируется и сохраняется в другом в расширении ресурса Godot (.import, .sample ...).

При изменении исходного файла присходит автоматическое перекомпилирование во время работы реадктора. Если был рантайм, то необходимо переимпортировать или перезапустить движок.

**Вопрос 5. Что такое _process() и _physics_process() в GDScript и чем они отличаются?**

_process() и _physics_process() - это основные циклы обновления в Godot. По сути они выполняют ту же функцию, что и Update() и FixedUpdate() в Unity, но чуть чуть отличается.

_process(): частота выполнения зависит от fps, синхронизируется с рентерингом, поэтому используется для отрисовки графики и UI.

_physics_process(): фиксированная частота выполнения, синхронизируется с физическим движком, поэтому используется для реализации физики, движения, коллизий ...

**Вопрос 6. Как создать и использовать таймер (Timer) в Godot?**

Таймеры в Godot - это инструмент для создания задержек, периодических событий и отсчета времени. Рассмотрим как его создать на примере из проекта:

В скрипте player_char.gd используется следующая строка:

	await get_tree().create_timer(dash_duration).timeout

Тут создается таймер функцией create_timer(), и программа ждет до его конца (timeout), чтобы продолжить выполнение.

Если необходимо настраивать таймер облее детально, то можно создать его следующим образом:
	
	func create_timer():
		## Создаем таймер
		timer = Timer.new()
	
		## Настраиваем параметры
    	timer.wait_time = 3.0  ## 3 секунды
    	timer.one_shot = true  ## Одноразовый
	    timer.autostart = false  ## Не запускать автоматически

		## Добавляем в сцену
    	add_child(timer)
    
	    ## Подключаем сигнал
	    timer.timeout.connect(_on_timer_timeout)

	func _on_timer_timeout():
    	pass

**Вопрос 7. Объясните, как работает система слоев и масок (Layers and Masks) для коллизий в Godot.**

Слои - это группы объектов. Когда мы определяем новую сцену или узел, мы указываем ему на каком слое он находится. (collision_layer = 1)

Маски - это указание для объектов, с какими слоями они будут взаимодействовать. (collision_mask = 2)

Всего слоев может быть 32, т.к. godot записывает слои и маски с 32-битную переменную, где 0 - не используемый слой, а 1 - используемый.

Чтобы коллизии объектов взаимодействовали, их маски должны совпадать со слоями объектов, с которыми надо взаимодействовать.

Например, чтобы игрок и стены могли взаимодействовать, игрок находится на слое 2 (collision_layer = 2), стены находятся на слое 1 (collision_layer = 2), а маска игрока - 2 (collision_mask = 1)

**Вопрос 8. Как в GDScript организовать взаимодействие между разными сценами или узлами?**

Основное направление, как организуется взаимодействие между сценами, это сигналы. Я уже показывала пример из проекта, как это сделано, в вопросе 2. 

Также можно взаиможействовать через массовое взаимодейсвие - управление группами, т.е. мы добавляем одну сцену в группу, а потом взаимодействуем с ней через get_tree().get_nodes_in_group("enemies")

Пример:
Coin_collider.gd
	
	func _ready(): 
		add_to_group("coins")

main_scene.gd
	
	func connect_to_coins():
		var coins = get_tree().get_nodes_in_group("coins")
		for coin in coins:
			coin.collected.connect(_on_coin_collected)

**Вопрос 9. Как загрузить и инстанцировать сцену динамически во время выполнения игры?**

Чтобы загрузить сцену во время игры необходимо сделать следующее (пример из проекта):

tile_map.gd

	## Создает монету по указанным координатам.
	func create_coin(x:int, y:int):
		var dot_scene = preload("res://Scenes/coins.tscn") ## Загрузка сцены динамически
		var dot_instance = dot_scene.instantiate() ## Ее инстанцирование
		dot_instance.position = map_to_local(Vector2i(x, y))
		add_child(dot_instance) ## Добавление в иерархию
	
	## Создает игрока по указанным координатам.
	func create_player(x:int, y:int):
		var player_scene = preload("res://Scenes/player_char.tscn")
		var player_instance = player_scene.instantiate()
		player_instance.position = map_to_local(Vector2i(x, y))
		add_child(player_instance)
	
	## Создает противника по указанным координатам.
	func create_ghost(x:int, y:int):
		var ghost_scene = preload("res://Scenes/ghost.tscn")
		var ghost_instance = ghost_scene.instantiate()
		ghost_instance.position = map_to_local(Vector2i(x, y))
		add_child(ghost_instance)

**Вопрос 10. Какие средства профилирования и отладки предоставляет Godot? Как ими пользоваться?**

1. Встроенный отладчик. Чтобы запустить надо просто нажать F5 или кнопку Debug. Можно добавить точки остановки, на которых выполнение программы будет приостановлено, и можно будет посмотреть какие данные записаны в переменных, как завершились выполнения методов до этого момента.
2. Профилировщик. Чтобы запустить надо выбрать в меню Profiler. он показывает время физичеких расчетов, время выполнения _process() и _physics_process(), время рендеринга, время выполнения каждого скрипта, детальный разбор времени выполнения функций.

**Вопрос 11. Как реализовать систему сохранения и загрузки данных игры в Godot? Какие существуют подходы и какие классы для этого используются?**

Сохранение можно выполнить через сохранение данных в файл,сохранение данных в файл JSON, возможно также добавление шифрования.
Чтобы сделать сохранение и загрузку данных необходимо выделить все объеты и переменные, которые нуждаются в сохранении, написать перевод данных из типов в строки, а затем перевести получившиеся данные в Json и записать в файл. 

Рассмотрим на примере из проекта (представлен только кусочек кода):

Базовый файл save_data.gd, который содержит одноименный класс. его мы и будем записывать в json. В самом файле реализована логика преобразования данных в строки
	
	class_name SaveData
	
	var score: int
	var player_position: Vector2 ## Положение игрока.
	var ghosts_positions: Dictionary = {}  ## Все призраки и их позиции.

	## Формируем SaveData.
	func to_dict() -> Dictionary:
		return {
			"score": score,
			"player_position": { "x": player_position.x, "y": player_position.y },
			"ghosts_positions": _vector2_dict_to_dict(ghosts_positions)
		}
	
	## Загружаем SaveData.
	func from_dict(data: Dictionary) -> void:
		score = data.get("score", 0)
		player_position = _dict_to_vector2(data.get("player_position", {}))
		ghosts_positions = _dict_to_vector2_dict(data.get("ghosts_positions", {}))

Преобразование SaveData в json и запись в файл происходит в файле save_manager.gd:

	const SAVE_DIR = "user://saves/"
	const SAVE_FILE = SAVE_DIR + "save_%d.dat"
	
	## Создает файл сохранения на основании SaveData.
	func _ready():
		##  Создаем директорию для сохранений если не существует
		DirAccess.make_dir_absolute(SAVE_DIR)

	##Сохраняет SaveData в файл
	func save_game(save_data: SaveData) -> bool:
		var file_path = SAVE_FILE
		var file = FileAccess.open(file_path, FileAccess.WRITE)

		## Преобразуем данные сохранения и записываем в файл
		var json_string = JSON.stringify(save_data.to_dict())
		file.store_string(json_string)
		file.close()
		
		return true
	
	## Возвращает SaveData из файла сохранения.
	func load_game() -> SaveData:
		var file_path = SAVE_FILE
		
		var file = FileAccess.open(file_path, FileAccess.READ)

		## Читаем файл
		var json_string = file.get_as_text()
		file.close()
		
		## Расшифровываем файл
		var json = JSON.new()
		var parse_result = json.parse(json_string)
		if parse_result != OK:
			push_error("Ошибка парсинга JSON")
			return null
			
		## Переписываем данные в save_data
		var data = json.data
		var save_data = SaveData.new()
		save_data.from_dict(data)

		return save_data

И третий файл, я его назвала level_manager.gd, в нем управляется создание SaveData и запись ее в файл:

	## Возвращает все необходимые данные для сохранения.
	func collect_save_data() -> SaveData:
		var save_data = SaveData.new()
		save_data.score = $"..".score
		
		## Сохраняем игрока
		var player = get_tree().get_first_node_in_group("player")
		var playerData = player.get_save_data()
		save_data.player_position = playerData.position
		
		## Сохраняем противников
		var enemies = get_tree().get_nodes_in_group("enemies")
		var enemiesData: Dictionary = {}
		for enemy in enemies:
			enemiesData[enemiesData.size()+1] = enemy.get_save_data()
		save_data.ghosts_positions = enemiesData
		
		return save_data
	
	## Загружает все содержимое сохранения.
	func load_save_data(save_data: SaveData) -> void:
		$"..".score = save_data.score
		
		## Загружаем игрока
		var player = get_tree().get_first_node_in_group("player")
		player.global_position = save_data.player_position
		
		## Загружаем противников
		var enemies = get_tree().get_nodes_in_group("enemies")
		for enemy in enemies:
			enemy.queue_free()
		for key in save_data.ghosts_positions:
			var ghost_scene = preload("res://Scenes/ghost.tscn")
			var ghost_instance = ghost_scene.instantiate()
			ghost_instance.position = save_data.ghosts_positions[key]
			ghost_instance.scale = Vector2.ONE * 1.5
			add_child(ghost_instance)

**Вопрос 12. Как подключить и использовать Android плагины в Godot? Какие шаги необходимы для интеграции?**

Для того, чтобы использовать плагины Android в проекте, необходимо:
1. Установить Android Build Template в настройках проекта в Godot.
2. Скопировать файлы плагина (например, .aar) в папку res://android/plugins проекта.
3. Создать файл конфигурации плагина (например, .gdap) — он помогает Godot обнаружить и загрузить плагин.

Пример такого файла:

	[config]
	name="YourAndroidPlugin"
	binary_type="local"
	binary="YourPlugin.aar"
	
	[dependencies]
	remote=[]
	local=[]
	custom=[]

4. В настройках проекта установить флажок "Use Custom Build" и добавить плагин в раздел "Custom Package".
5. Если плагин реализован как модуль, в файле AndroidManifest.xml модуля нужно добавить информацию о плагине, чтобы игра смогла найти его и загрузить.
6. При экспорте проекта необходимо проверить, что у модулей стоят разрешения.

_После выполнения тестового задания сразу хочу сказать спасибо за уделенное время на его проверку! Мне было очень интересно разбираться в возможностях движка, который я никогда до этого не трогала. Синтаксис оказался похожим на синтаксис питона, но какая-то схожесть с C# также присутствует. Система сцен мне также показалась очень интересной. Буду рада и дальше разбираться в возможностям движка и создавать на нем игры, если предоставится возможность!_
